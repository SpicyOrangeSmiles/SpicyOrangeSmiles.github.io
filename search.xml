<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>外星人本人成长史</title>
      <link href="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/"/>
      <url>/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="0" height="0" src="//music.163.com/outchain/player?type=2&amp;id=3951888&amp;auto=1&amp;height=66"></iframe><h1 id="来地球的第一年"><a href="#来地球的第一年" class="headerlink" title="来地球的第一年"></a>来地球的第一年</h1><h2 id="独自生长"><a href="#独自生长" class="headerlink" title="独自生长"></a>独自生长</h2><p><img src="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/logo.png" alt="菇菇1"></p><h1 id="来地球的第二年"><a href="#来地球的第二年" class="headerlink" title="来地球的第二年"></a>来地球的第二年</h1><h2 id="学会变色"><a href="#学会变色" class="headerlink" title="学会变色"></a>学会变色</h2><p><img src="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/%E8%8F%87%E8%8F%871.png" alt="菇菇1"></p><h2 id="学会变身"><a href="#学会变身" class="headerlink" title="学会变身"></a>学会变身</h2><p><img src="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/R.gif" alt="R"></p><h1 id="来地球的第三年"><a href="#来地球的第三年" class="headerlink" title="来地球的第三年"></a>来地球的第三年</h1><h2 id="晚上吃晚饭，吸走银河系"><a href="#晚上吃晚饭，吸走银河系" class="headerlink" title="晚上吃晚饭，吸走银河系"></a>晚上吃晚饭，吸走银河系</h2><p><img src="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/1.gif" alt="giphy"></p><h1 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h1><h2 id="穿上我的伪装"><a href="#穿上我的伪装" class="headerlink" title="穿上我的伪装"></a>穿上我的伪装</h2><p><img src="/2022/07/01/%E4%B8%80%E4%B8%AA%E8%87%AA%E6%8B%8D/giphy.gif" alt="giphy"></p>]]></content>
      
      
      <categories>
          
          <category> 自传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DAS HOFFE ICH</title>
      <link href="/2022/07/01/DAS%20HOFFE%20ICH/"/>
      <url>/2022/07/01/DAS%20HOFFE%20ICH/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Und was willst du in deinem Leben erreichen</p><p>Was machst du Morgens gern</p><p>Wir konnten Morgens uns betrinken, wir waren total uberrascht</p><p>Wir gehen gern joggen und dusche hinterher es ist mein Leben, es war so langweilig</p><p>Ich denkt, dass es war letzte Nacht eine schöne Zeit</p><p>Ich bin Zwangzig Jahren lang echt wutend</p><p>Weil Erwachsene waren nicht auch mal jung</p><p>Er fragten mich, ob ich habe mal im Himmel gewohnt</p><p>Ich ihm rede, dass ich habe einundzwangzig Jahren auf dich gewartet</p><p>Nein, ich wohne nicht im Himmel bis zu deinem Auftritt</p><p>Meine Zeele hat mir davon erzahlt, dass</p><p>Wir sollten uns das sagen</p><p>Es musste sein</p><p>Und Eltern mussten vor zweiundzwangzig Jahren mir alles erzahlen</p><p>Weil wir wollten nicht mitgehen, aber wir mussten</p><p>Weil wir konnten nicht wissen, aber wir mussten</p><p>Weil wir sollten nicht ihn verstehen, baer wir mussten</p>]]></content>
      
      
      <categories>
          
          <category> poet is me, the alien </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拼凑的诗意 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array &amp; List</title>
      <link href="/2022/07/01/Array%20&amp;%20List/"/>
      <url>/2022/07/01/Array%20&amp;%20List/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><ul><li>世间上本来没有集合,(只有数组参考C语言)但有人想要,所以有了集合  <ul><li>最基础的是array,所有的集合都是通过array实现的。</li></ul></li><li>例子：<ul><li>有人想有可以自动扩展的数组,所以有了List  </li><li>有的人想有没有重复的数组,所以有了set  </li><li>有人想有自动排序的组数,所以有了TreeSet,TreeList,Tree</li></ul></li></ul><h1 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h1><ul><li><p>List 优点：集合是对数组做的封装,所以,在代码中进行随机访问和存储，array的效率是最高的</p></li><li><p>Array 优点：比数组提供的功能要多  </p><ul><li>array是==固定==的，不能动态改变，且一个array只能存放==同一种数据类型==，可存放==引用类型/基本数据类型==；</li><li>List反之，可以存储和操作==不固定的一组数据==，但是只能存放==引用类型==的数据，不能放基本数据类型</li><li>数组是一种可读/可写数据结构，没有办法创建一个只读数组。然而可以使用==集合提供的ReadOnly==方法，以==只读==方式来使用集合。</li></ul></li><li><p>List集合的方法</p><ul><li>add(int index,E element)<ul><li>作用：<ul><li>用于==在列表的指定位置插入指定元素，并将当前处于该位置的元素及其后续元素的索引加1==</li></ul></li><li>参数说明: <ul><li>index: 用于指定在其中插入指定元素处的索引。</li><li>element:于指定要插入的元素。</li></ul></li><li>说明:索引值从0开始。</li></ul></li></ul></li></ul><h1 id="数组转换成集合"><a href="#数组转换成集合" class="headerlink" title="数组转换成集合"></a>数组转换成集合</h1><h2 id="使用：Arrays-asList"><a href="#使用：Arrays-asList" class="headerlink" title="使用：Arrays.asList()"></a>使用：Arrays.asList()</h2><ul><li><p>注意点</p><ul><li>转换后的集合，如果要使用 add/remove/clear ，那么会<code>java.lang.UnsupportedOperationException</code> 异常。</li><li>这个 ArrayList 类并非 java.util.ArrayList 类，而是 Arrays 类的静态内部类！</li></ul></li><li><p>需要增加删除操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WaiterLevel&gt; levelList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WaiterLevel&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap &amp; LinkedHashMap</title>
      <link href="/2022/07/01/Hashmap%20&amp;%20LinkedHashMap/"/>
      <url>/2022/07/01/Hashmap%20&amp;%20LinkedHashMap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。（TreeMap取出来的是排序后的键值对）</li><li>HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>getOrDefault(K, V)</p><ul><li><p>运算：</p><ul><li>当Map集合中有这个key时，就使用这个key值；<br>如果没有就使用默认值defaultValue。</li></ul></li><li><p>目的：为了统计字符串中每种字符出现的频率</p></li><li><p>用法1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果在Map中存在key，则返回key所对应的的value。</span></span><br><span class="line"><span class="comment">//如果在Map中不存在key，则返回默认值。</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"cookie"</span>);</span><br><span class="line">    map.put(<span class="string">"age"</span>, <span class="string">"18"</span>);</span><br><span class="line">    map.put(<span class="string">"sex"</span>, <span class="string">"女"</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> map.getOrDefault(<span class="string">"name"</span>, <span class="string">"random"</span>);</span><br><span class="line">    System.out.println(name);<span class="comment">// cookie，map中存在name,获得name对应的value</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> map.getOrDefault(<span class="string">"score"</span>, <span class="number">80</span>);</span><br><span class="line">    System.out.println(score);<span class="comment">// 80，map中不存在score,使用默认值80    </span></span><br></pre></td></tr></tbody></table></figure></li><li><p>用法拓展：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若没有就是0再加上1，有就直接加1</span></span><br><span class="line">hash.put(c,hash.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>); </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>get()方法</p><ul><li>使用 key 获取value</li></ul></li><li><p>keySet() 方法</p><ul><li>返回所有 key 组成的 set 集合视图</li></ul></li></ul><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><h2 id="当我们期待一个有序的Map，为什么不用HashMap？"><a href="#当我们期待一个有序的Map，为什么不用HashMap？" class="headerlink" title="当我们期待一个有序的Map，为什么不用HashMap？"></a>当我们期待一个有序的Map，为什么不用HashMap？</h2><ul><li>HashMap<ul><li>迭代HashMap的顺序并不是HashMap放置的顺序，也就是无序</li></ul></li><li>LinkedHashMap<ul><li>虽然增加了时间和空间上的开销，但是<strong>通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序</strong>。<strong>该迭代顺序可以是插入顺序或者是访问顺序。</strong></li></ul></li></ul><h2 id="LinkedHashMap的特点"><a href="#LinkedHashMap的特点" class="headerlink" title="LinkedHashMap的特点"></a>LinkedHashMap的特点</h2><ul><li><table><thead><tr><th><strong>关  注  点</strong></th><th><strong>结    论</strong></th></tr></thead><tbody><tr><td>LinkedHashMap是否允许空</td><td>Key和Value都允许空</td></tr><tr><td>LinkedHashMap是否允许重复数据</td><td>Key重复会覆盖、Value允许重复</td></tr><tr><td>LinkedHashMap是否有序</td><td><strong>有序</strong></td></tr><tr><td>LinkedHashMap是否线程安全</td><td>非线程安全</td></tr></tbody></table></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sex Pistols - God Save The Queen</title>
      <link href="/2022/07/01/God%20Save%20The%20Queen/"/>
      <url>/2022/07/01/God%20Save%20The%20Queen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"> <iframe src="//player.bilibili.com/player.html?aid=590125678&amp;bvid=BV1Vq4y1U7H6&amp;cid=397827679&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" autoplay="autoplay" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;"></iframe></div> ]]></content>
      
      
      <categories>
          
          <category> Song </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>My Little Airport - HEY HEY BABY</title>
      <link href="/2022/07/01/heyheybaby/"/>
      <url>/2022/07/01/heyheybaby/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="0" allowfullscreen="" width="700" height="500" src="https://www.youtube.com/embed/LI6jrBb-Nes" title="YouTube video player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe># Tip：YouTuBe观看]]></content>
      
      
      <categories>
          
          <category> Song </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/07/01/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/07/01/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计算机为什么要使用 二进制 ？<br>因为简单，我们可以通过电路的开合来表示二进制。</p><p>十进制是人类使用的运算单位；<br>而计算机只能识别二进制，计算机之所以能计算十进行运算，<br>是因为在底层最终都是转化成二进制的运算，也就是 CPU的加法器</p><h1 id="位异或（-）："><a href="#位异或（-）：" class="headerlink" title="位异或（^）："></a>位异或（^）：</h1><h2 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h2><ul><li>==相同数字得0，不同数组得1==//超奇怪！必须不同搭配才给你pass！</li></ul><h2 id="几个性质"><a href="#几个性质" class="headerlink" title="几个性质"></a>几个性质</h2><ul><li>交换律 ==<strong>A ^ B = B ^ A</strong>==</li><li>结合律 ==<strong>A ^ B = C 则 A ^ C = B</strong>==</li><li>自反性  ==<strong>A ^ B = C 则 C ^ B = A</strong>==</li><li>与0的规则：==<strong>A^A=0，A^0=A</strong>==</li><li>与-1的规则：为自身的值按位取反值：==<strong>A ^ -1 = ~A</strong>==  //001 ^ -1 = 110 = 6</li><li>与1的规则：<ul><li>==<strong>A (奇数)</strong> ^1 = <strong>偶数</strong>==</li><li>==<strong>A (偶数)</strong> ^1 = <strong>奇数</strong>==</li></ul></li></ul><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li><p>翻转指定位</p><ul><li>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。</li></ul></li><li><p>与0相异或值不变</p><ul><li>例如：1010 1110 ^ 0000 0000 = 1010 1110</li></ul></li><li><p>交换两个数</p><ul><li><pre><code class="java">void Swap(int &amp;a, int &amp;b){    if (a != b){        a ^= b;        b ^= a;        a ^= b;    }}</code></pre></li></ul></li></ul><h1 id="位与（-amp-）："><a href="#位与（-amp-）：" class="headerlink" title="位与（&amp;）："></a>位与（&amp;）：</h1><h2 id="规则：-1"><a href="#规则：-1" class="headerlink" title="规则："></a>规则：</h2><ul><li><strong>两个位都为 1 时，结果才为 1，</strong>否则为 0；//很严格，两个都要是1才给你pass！</li></ul><h2 id="几个性质-1"><a href="#几个性质-1" class="headerlink" title="几个性质 :"></a>几个性质 :</h2><ul><li>与0的规则：==<strong>A &amp; 0=0</strong>==  //001 &amp; 000 = 000 （有0猪队友，团灭）</li><li>与1的规则：：==<strong>A &amp; 1 = 1</strong>==  //101 &amp; 001 = 001 （有一个东北1，口音全部都被传染了）</li></ul><h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><ul><li>清零<ul><li>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</li></ul></li><li>取一个数的指定位<ul><li>比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。</li></ul></li><li>判断奇偶<ul><li>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</li></ul></li></ul><h1 id="位或（-）："><a href="#位或（-）：" class="headerlink" title="位或（|）："></a>位或（|）：</h1><h2 id="规则：-2"><a href="#规则：-2" class="headerlink" title="规则："></a>规则：</h2><ul><li>有1则1；//不很严格，一个是1就给pass！</li></ul><h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><ul><li><p>对一个数据的某些位设置为1</p><p>比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。</p></li></ul><h1 id="取反"><a href="#取反" class="headerlink" title="取反 (~) :"></a>取反 (~) :</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul><li>总结：对一个二进制数按位取反，即将0变1，1变0。</li></ul><h2 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h2><ul><li><p>使一个数的最低位为零</p><p>使a的最低位为0，可以表示为：a &amp; <del>1。</del>1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>菇菇之诗</title>
      <link href="/2022/07/01/%E8%8F%87%E8%8F%87%E4%B9%8B%E8%AF%97/"/>
      <url>/2022/07/01/%E8%8F%87%E8%8F%87%E4%B9%8B%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>菇菇喜欢踩踩</p><p>小黄鸡踩踩</p><p>在头上踩踩</p><p>踩成大蘑菇</p><p>大蘑菇变成大树</p><p>大树变成小草</p><p>小草变成小花</p><p>小花变成小鸟</p><p>这就是菇菇的诗</p>]]></content>
      
      
      <categories>
          
          <category> 外星人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蘑菇 </tag>
            
            <tag> 好吃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杀死一只知更鸟</title>
      <link href="/2022/07/01/%E6%9D%80%E6%AD%BB/"/>
      <url>/2022/07/01/%E6%9D%80%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 1.民主不一定是好事，一旦一个群体形成了一种合意的偏见，民主就是促成偏见转变成欺压的工具。 </p><p>2.伪善的群落：人们倾向于与自己群落内的保持一种一致性，而不是思考事情本身的对与错。这样的一种道德观，其实质意义上就是非道德的，建立在这个基础上的正义感，其本身就是一种伪善。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学家 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模1000000007</title>
      <link href="/2022/07/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81Mod%201e9+7/"/>
      <url>/2022/07/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81Mod%201e9+7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>大数相乘，大数的排列组合等为什么要取模</p><ul><li>1000000007是一个质数（素数），对质数取余能最大程度避免结果冲突/重复</li><li>int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。</li><li>int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。</li><li>所以在大数相乘问题中，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。</li></ul></li><li><p>这道题为什么要取模，取模前后的值不就变了吗？</p><ul><li>确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) &gt; 2147483647结果就溢出了。</li><li>取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。</li><li>取模之后能够计算更多的情况，如 f(46)</li><li>这道题的测试答案与取模后的结果一致。</li></ul></li><li><p>总结一下：</p><ul><li>这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
