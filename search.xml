<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>For Loop总结</title>
      <link href="/2022/07/01/For-Loop%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/01/For-Loop%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="For-Loop的几种写法"><a href="#For-Loop的几种写法" class="headerlink" title="For Loop的几种写法"></a>For Loop的几种写法</h2><ul><li><p>传统数组遍历</p><ul><li>```java<br>String[] persons={“张三”,”李四”,”王五”};<br>    for(int i=0;i&lt;persons.length;i++){<br>        System.out.println(persons[i]);<br>    }  <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 传统的Iterator遍历集合  </span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    List&lt;String&gt; persons=new ArrayList&lt;String&gt;();  </span><br><span class="line">           persons.add("张三");  </span><br><span class="line">           persons.add("李四");  </span><br><span class="line">           persons.add("王五");  </span><br><span class="line">            for(Iterator&lt;String&gt; i=persons.iterator();i.hasNext();){  </span><br><span class="line">               String person=i.next();  </span><br><span class="line">               System.out.println(person);  </span><br><span class="line">           } </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>增强for</p><ul><li>```java<br>int[] arr = {1,2,3};<br>for(int i : arr) {<br>System.out.println(i);<br>}<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 格式：</span><br><span class="line"></span><br><span class="line">    - 增强for的冒号左边是定义变量，右边必须是数组或集合类型。例如上例中循环遍历的主浊arr这个int数组，==增强for内部会依次把arr中的元素赋给变量i==</span><br><span class="line"></span><br><span class="line">  - 实现：内部是使用==迭代器==完成的！也就是说，任何实现了Iterable接口的对象都可以被增强for循环遍历</span><br><span class="line"></span><br><span class="line">  - 缺点：</span><br><span class="line"></span><br><span class="line">    -  ==只能从头到尾的遍历数组或集合==，而不能只遍历部分；</span><br><span class="line">    -  在遍历List或数组时，==不能获取当前元素下标==；</span><br><span class="line"></span><br><span class="line">  - 优点：</span><br><span class="line"></span><br><span class="line">    - 增强for使用便简单</span><br><span class="line"></span><br><span class="line">## For Loop里面删除</span><br><span class="line"></span><br><span class="line">#### 常用for循环删除元素</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;list.size();i++){</span><br><span class="line">    if(list.get(i).equals("delele"))</span><br><span class="line">        list.remove(i);</span><br><span class="line">}</span><br><span class="line">注：这种方法可以删除元素，但是删除的同时索引在增加，列表的size在减小，导致最后会漏删</span><br><span class="line"></span><br><span class="line">除非这种形式：n不会list变小而减小</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">int n = list.size()</span><br><span class="line">for(int i=0;i&lt; n;i++){</span><br><span class="line">    if(list.get(i).equals("delele"))</span><br><span class="line">        list.remove(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h4 id="增强型for循环"><a href="#增强型for循环" class="headerlink" title="增强型for循环"></a>增强型for循环</h4><p>for(String s:list){<br>    if(s.equals(“delete”))<br>        list.remove(x);<br>}<br>注：可删除元素，若删除元素后继续循环则会报ConcurrentModificationException异常。</p><p>为什么：</p><ul><li><strong>原来增强for循环中的循环变量相当于一个临时变量，系统会把数组元素依次赋给这个临时变量，而这个临时变量并不是数组元素，它只是保存了数组元素的值。</strong></li><li><strong>所以当你赋值时，只是改变了临时变量的值，并不能改变原数组的值。</strong></li><li><strong>只适合用于数据的读取</strong></li><li><strong>改变数组中的元素的值，还是通过索引使用 arr[index] 这样的方法赋值</strong></li></ul><h2 id="For-Loop的省略"><a href="#For-Loop的省略" class="headerlink" title="For Loop的省略"></a>For Loop的省略</h2><blockquote><p>for (初始化语句; 条件语句; 控制语句){</p><p>　　被执行的代码块</p><p>};</p><p>===&gt;</p><p>for(;;;){</p><p>被执行的代码块</p><p>}</p></blockquote><ul><li>for循环中，“初始化语句”、“条件语句”和“控制语句”都可以省略，但是其间的分号不能省略。</li><li>同时，省略“条件语句”时，在for语句{}中必须包含跳出语句控制程序在某个条件满足时跳出for循环，否则将形成死循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> For Loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array &amp; List</title>
      <link href="/2022/07/01/Array%20&amp;%20List%20/"/>
      <url>/2022/07/01/Array%20&amp;%20List%20/</url>
      
        <content type="html"><![CDATA[<ul><li><p>关系</p><ul><li><p>世间上本来没有集合,(只有数组参考C语言)但有人想要,所以有了集合  </p><ul><li>最基础的是array,所有的集合都是通过array实现的。</li><li></li></ul></li><li><p>例子：</p><ul><li>有人想有可以自动扩展的数组,所以有了List  </li><li>有的人想有没有重复的数组,所以有了set  </li><li>有人想有自动排序的组数,所以有了TreeSet,TreeList,Tree**</li></ul></li></ul></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>List 优点：集合是对数组做的封装,所以,在代码中进行随机访问和存储，array的效率是最高的</p></li><li><p>Array 优点：比数组提供的功能要多  </p><ul><li>array是==固定==的，不能动态改变，且一个array只能存放==同一种数据类型==，可存放==引用类型/基本数据类型==；</li><li>List反之，可以存储和操作==不固定的一组数据==，但是只能存放==引用类型==的数据，不能放基本数据类型</li><li>数组是一种可读/可写数据结构，没有办法创建一个只读数组。然而可以使用==集合提供的ReadOnly==方法，以==只读==方式来使用集合。</li></ul></li><li><p>List集合的方法</p><ul><li>add(int index,E element)<ul><li>作用：<ul><li>用于==在列表的指定位置插入指定元素，并将当前处于该位置的元素及其后续元素的索引加1==</li></ul></li><li>参数说明: <ul><li>index: 用于指定在其中插入指定元素处的索引。</li><li>element:于指定要插入的元素。</li></ul></li><li>说明:索引值从0开始。</li></ul></li></ul></li></ul><h3 id="数组转换成集合"><a href="#数组转换成集合" class="headerlink" title="数组转换成集合"></a>数组转换成集合</h3><h5 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList()"></a><code>Arrays.asList()</code></h5><ul><li><p>注意点</p><ul><li>转换后的集合，如果要使用 add/remove/clear ，那么会<code>java.lang.UnsupportedOperationException</code> 异常。</li><li>这个 ArrayList 类并非 java.util.ArrayList 类，而是 Arrays 类的静态内部类！</li></ul></li><li><p>需要增加删除操作</p><blockquote><p>List<waiterlevel> levelList = new ArrayList<waiterlevel>(Arrays.asList(“a”, “b”, “c”));</waiterlevel></waiterlevel></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Array </tag>
            
            <tag> List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DAS HOFFE ICH</title>
      <link href="/2022/07/01/DAS%20HOFFE%20ICH%20/"/>
      <url>/2022/07/01/DAS%20HOFFE%20ICH%20/</url>
      
        <content type="html"><![CDATA[<p>Und was willst du in deinem Leben erreichen </p><p>Was machst du Morgens gern </p><p>Wir konnten Morgens uns betrinken, wir waren total uberrascht</p><p>Wir gehen gern joggen und dusche hinterher es ist mein Leben, es war so langweilig </p><p>Ich denkt, dass es war letzte Nacht eine schöne Zeit</p><p>Ich bin Zwangzig Jahren lang echt wutend</p><p>Weil Erwachsene waren nicht auch mal jung</p><p>Er fragten mich, ob ich habe mal im Himmel gewohnt  </p><p>Ich ihm rede, dass ich habe einundzwangzig Jahren auf dich gewartet </p><p>Nein, ich wohne nicht im Himmel bis zu deinem Auftritt </p><p>Meine Zeele hat mir davon erzahlt, dass  </p><p>Wir sollten uns das sagen </p><p>Es musste sein </p><p>Und Eltern mussten vor zweiundzwangzig Jahren mir alles erzahlen  </p><p>Weil wir wollten nicht mitgehen, aber wir mussten </p><p>Weil wir konnten nicht wissen, aber wir mussten  </p><p>Weil wir sollten nicht ihn verstehen, baer wir mussten</p>]]></content>
      
      
      <categories>
          
          <category> poet is me, the alien </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拼凑的诗意 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hashmap &amp; LinkedHashMap</title>
      <link href="/2022/07/01/Hashmap%20&amp;%20LinkedHashMap/"/>
      <url>/2022/07/01/Hashmap%20&amp;%20LinkedHashMap/</url>
      
        <content type="html"><![CDATA[<ul><li><p>Hashmap</p><ul><li><p>特点</p><ul><li>HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。（TreeMap取出来的是排序后的键值对）</li><li>HashMap的底层是Array，所以HashMap在添加，查找，删除等方法上面速度会非常快</li></ul></li><li><p>方法</p><ul><li><p>getOrDefault(K, V)</p><ul><li><p>运算：</p><ul><li>当Map集合中有这个key时，就使用这个key值；<br>如果没有就使用默认值defaultValue。</li></ul></li><li><p>目的：为了统计字符串中每种字符出现的频率</p></li><li><p>用法1：</p><blockquote><p>如果在Map中存在key，则返回key所对应的的value。<br>如果在Map中不存在key，则返回默认值。</p></blockquote></li><li><p>```java<br>HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();<br>map.put(“name”, “cookie”);<br>map.put(“age”, “18”);<br>map.put(“sex”, “女”);<br>String name = map.getOrDefault(“name”, “random”);<br>System.out.println(name);// cookie，map中存在name,获得name对应的value<br>int score = map.getOrDefault(“score”, 80);<br>System.out.println(score);// 80，map中不存在score,使用默认值80    </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用法拓展：</span><br><span class="line"></span><br><span class="line">  &gt; 若没有就是0再加上1，有就直接加1</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  hash.put(c,hash.getOrDefault(c,0)+1); </span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>get()方法</p><ul><li>使用 key 获取value</li></ul></li><li><p>keySet() 方法</p><ul><li>返回所有 key 组成的 set 集合视图</li></ul></li></ul></li></ul></li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul><li><p>当我们期待一个有序的Map，为什么不用HashMap？</p><ul><li>HashMap<ul><li>迭代HashMap的顺序并不是HashMap放置的顺序**，也就是无序</li></ul></li><li>LinkedHashMap<ul><li>虽然增加了时间和空间上的开销，但是<strong>通过维护一个运行于所有条目的双向链表，==LinkedHashMap保证了元素迭代的顺序==<strong>。</strong>该迭代顺序可以是插入顺序或者是访问顺序。</strong></li></ul></li></ul></li><li><p>LinkedHashMap的特点</p><ul><li><table><thead><tr><th><strong>关  注  点</strong></th><th><strong>结    论</strong></th></tr></thead><tbody><tr><td>LinkedHashMap是否允许空</td><td>Key和Value都允许空</td></tr><tr><td>LinkedHashMap是否允许重复数据</td><td>Key重复会覆盖、Value允许重复</td></tr><tr><td>LinkedHashMap是否有序</td><td><strong>有序</strong></td></tr><tr><td>LinkedHashMap是否线程安全</td><td>非线程安全</td></tr></tbody></table></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模1000000007</title>
      <link href="/2022/07/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81Mod%201e9+7/"/>
      <url>/2022/07/01/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81Mod%201e9+7/</url>
      
        <content type="html"><![CDATA[<p>为什么要模1000000007（跟我念，一，八个零，七）。</p><ol><li>大数相乘，大数的排列组合等为什么要取模<ul><li>1000000007是一个质数（素数），对质数取余能最大程度避免结果冲突/重复</li><li>int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。</li><li>int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。</li><li>所以在大数相乘问题中，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。</li></ul></li><li>这道题为什么要取模，取模前后的值不就变了吗？<ul><li>确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) &gt; 2147483647结果就溢出了。</li><li>取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。</li><li>取模之后能够计算更多的情况，如 f(46)</li><li>这道题的测试答案与取模后的结果一致。</li></ul></li></ol><ul><li>总结一下，这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/2022/07/01/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/07/01/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>计算机为什么要使用 二进制 ？<br>因为简单，我们可以通过电路的开合来表示二进制。</p><p>十进制是人类使用的运算单位；<br>而计算机只能识别二进制，计算机之所以能计算十进行运算，<br>是因为在底层最终都是转化成二进制的运算，也就是 CPU的加法器</p><h3 id="位异或（-）："><a href="#位异或（-）：" class="headerlink" title="位异或（^）："></a>位异或（^）：</h3><h4 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h4><ul><li>==相同数字得0，不同数组得1==//超奇怪！必须不同搭配才给你pass！</li></ul><h4 id="几个性质"><a href="#几个性质" class="headerlink" title="几个性质"></a>几个性质</h4><ul><li>交换律 ==<strong>A ^ B = B ^ A</strong>==</li><li>结合律 ==<strong>A ^ B = C 则 A ^ C = B</strong>==</li><li>自反性  ==<strong>A ^ B = C 则 C ^ B = A</strong>==</li><li>与0的规则：==<strong>A^A=0，A^0=A</strong>==</li><li>与-1的规则：为自身的值按位取反值：==<strong>A ^ -1 = ~A</strong>==  //001 ^ -1 = 110 = 6</li><li>与1的规则：<ul><li>==<strong>A (奇数)</strong> ^1 = <strong>偶数</strong>==</li><li>==<strong>A (偶数)</strong> ^1 = <strong>奇数</strong>==</li></ul></li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li><p>翻转指定位</p><ul><li>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。</li></ul></li><li><p>与0相异或值不变</p><ul><li>例如：1010 1110 ^ 0000 0000 = 1010 1110</li></ul></li><li><p>交换两个数</p><ul><li><pre><code class="java">void Swap(int &amp;a, int &amp;b){    if (a != b){        a ^= b;        b ^= a;        a ^= b;    }}</code></pre></li></ul></li></ul><h3 id="位与（-amp-）："><a href="#位与（-amp-）：" class="headerlink" title="位与（&amp;）："></a>位与（&amp;）：</h3><h4 id="规则：-1"><a href="#规则：-1" class="headerlink" title="规则："></a>规则：</h4><ul><li><strong>两个位都为 1 时，结果才为 1，</strong>否则为 0；//很严格，两个都要是1才给你pass！</li></ul><h4 id="几个性质-1"><a href="#几个性质-1" class="headerlink" title="几个性质 :"></a>几个性质 :</h4><ul><li>与0的规则：==<strong>A &amp; 0=0</strong>==  //001 &amp; 000 = 000 （有0猪队友，团灭）</li><li>与1的规则：：==<strong>A &amp; 1 = 1</strong>==  //101 &amp; 001 = 001 （有一个东北1，口音全部都被传染了）</li></ul><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul><li>清零<ul><li>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</li></ul></li><li>取一个数的指定位<ul><li>比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。</li></ul></li><li>判断奇偶<ul><li>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a &amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。</li></ul></li></ul><h3 id="位或（-）："><a href="#位或（-）：" class="headerlink" title="位或（|）："></a>位或（|）：</h3><h4 id="规则：-2"><a href="#规则：-2" class="headerlink" title="规则："></a>规则：</h4><ul><li>有1则1；//不很严格，一个是1就给pass！</li></ul><h4 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h4><ul><li><p>对一个数据的某些位设置为1</p><p>比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。</p></li></ul><h3 id="取反"><a href="#取反" class="headerlink" title="取反 (~) :"></a>取反 (~) :</h3><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><ul><li>总结：对一个二进制数按位取反，即将0变1，1变0。</li></ul><h4 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h4><ul><li><p>使一个数的最低位为零</p><p>使a的最低位为0，可以表示为：a &amp; <del>1。</del>1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为” ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杀死一只知更鸟</title>
      <link href="/2022/07/01/%E6%9D%80%E6%AD%BB/"/>
      <url>/2022/07/01/%E6%9D%80%E6%AD%BB/</url>
      
        <content type="html"><![CDATA[<p> 1.民主不一定是好事，一旦一个群体形成了一种合意的偏见，民主就是促成偏见转变成欺压的工具。 </p><p>2.伪善的群落：人们倾向于与自己群落内的保持一种一致性，而不是思考事情本身的对与错。这样的一种道德观，其实质意义上就是非道德的，建立在这个基础上的正义感，其本身就是一种伪善。</p>]]></content>
      
      
      <categories>
          
          <category> 哲学家 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菇菇之诗</title>
      <link href="/2022/07/01/%E8%8F%87%E8%8F%87%E4%B9%8B%E8%AF%97/"/>
      <url>/2022/07/01/%E8%8F%87%E8%8F%87%E4%B9%8B%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<p>菇菇之家</p><p>虽然我是外星人</p><p>但是蘑菇</p><p>是人间大bug</p><p>还有喜欢熊二</p><p>小黄鸡踩踩</p><p>在头上踩踩</p><p>踩成大蘑菇</p><p>这就是菇菇的诗</p>]]></content>
      
      
      <categories>
          
          <category> 外星人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蘑菇 </tag>
            
            <tag> 好吃 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
